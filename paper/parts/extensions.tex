\section{Type Annotations}

\subsection{Restrictions}
\label{restrictions}

Some invariants can be added to declarations and fields. These invariants can occur at the same place as comments, but can occur in any number. Invariants start with an \textsc{@} followed by a predicate. Each predicate has to supply a default argument \texttt{\%}, such that using only default arguments would not imply a restriction.
If multiple predicates are annotated, the conjunction of them forms the invariant.
The set of legal predicates is explained below.

If predicates, which are not directly applicable for compound types are used on compound types, they expand to the contents of the compound types, if applicable. Otherwise the usage of the predicate is illegal.

\todo{hier muss man zwischen serialisierbaren und nicht serialisierbaren restrictions unterscheiden; serialisierbar sind alle restrictions, die auch auswirkungen auf die potentiell gespeicherten daten haben, wie range und nonnull}


\subsection*{Range}
Range restrictions are used to restrict integers and floats.
\todo{Falls $0 \notin [min,max]$ wird der default $min$.}

Applies to fields: Integer, Float.

Signature: \verb/range(min, max)/: $\alpha \times \alpha → bool$

Defaults: obvious.

\begin{lstlisting}[label=rangeExample,caption=Examples,language=skill]
natural {
  @range(0,%)
  v64 data;
}
positive {
  @range(1,%)
  v64 data;
}
nonNegativeDouble {
  @range(0,%)
  f64 data;
}
\end{lstlisting}

\subsection*{NonNull}
Declares that an indexed field may not be null. Note that this will take away the default value and can therefore cause compatibility problems.

Applies to Field: Any indexed Type.

Signature: \verb/nonnull()/

Defaults: none.

\begin{lstlisting}[label=nonnullExample,caption=Examples,language=skill]
Node {
  @nonnull Node[] edges;
}
\end{lstlisting}


\subsection*{Unique}
Objects stored in a storage pool have to be distinct in their serialized form, i.e. for each pair of objects, there has to be at least one field, with a different value.

NOTE: This can cause difficulties in combination with sub-classing, because the uniqueness property must hold even on the part restricted to the topmost class declared to be unique.

Applies to Declarations of indexed types.

Signature: \verb/unique()/

Defaults: none.

\begin{lstlisting}[label=uniqueExample,caption=Examples,language=skill]
@unique Operator {
  string name;
}
@unique Term {
  Operator operator;
  Term[] arguments;
}
\end{lstlisting}


\subsection*{Singleton}
There is at most one instance of the declaration.

Applies to Declarations.

Signature: \verb/singleton()/

Defaults: none.

\begin{lstlisting}[label=singletonExample,caption=Examples,language=skill]
@singleton System { ... }
@singleton Data{
  /** Note: if data would not be a singleton itself, it is likely to violate the singleton property */
  System foo;
}
\end{lstlisting}


% \subsection*{Integer Renaming}
% In some languages it is possible to define subsets of integers by renameing the integer type. The type declaration must contain exactly one field of some integer type. The resulting type will be treated as integer type. Language support is encouraged to make use of language specific features such as typedefs. In Ada, this restriction should be processed together with the range restriction.


\subsection*{Ascription}
A language specific type can be ascribed to a field. The type has to be compatible to the fields actual type, because the ascription will not change the ABI in any way. The first argument is the language name. The second type is generator dependent, but should be related to types as they occur in local variable or field declaration in the respective language.

Although this kind of restriction puts a heavy burden on the language generator and decreases readability a lot, it can be used to increase the usability of the generated interface a lot, because language features such es enums in Java or unions and bitfields in C++ can be used.

Applies to fields.

Signature: \verb/as(language, type)/: $\texttt{string} \times \texttt{string} → \{\}$

Defaults: not allowed.

\begin{lstlisting}[label=ascriptionExample,caption=Examples,language=skill]
System {
  /**
  The language binding makes use of an enumeration, which is supplied with the generated code.
  
  The C++ interface will use the different type using C-Casts to convert between the two types (which is completely fine if the enum uses char as a base type).
  
  The Java interface will assume the stored integer to be the ordinal of the enum SystemState.
  */
  @as("C++", "ccast SystemState")
  @as("Java", "enum SystemState")
  i8 state
}
\end{lstlisting}



\subsection*{Tree}
The reference graph below created by objects of this type forms a tree. The type of the objects is irrelevant. Strings and fields with notree annotation, are not taken into account.

Applies to Declarations or Field.

Signature: \verb/tree()/

Defaults: none.


\subsubsection*{notree}
Applies to field.

Signature: \verb/notree()/

Defaults: none.

\begin{lstlisting}[label=treeExample,caption=Examples,language=skill]
Sloc{...}
@tree
SyntaktikEntity{
  /** not a tree, because several entities, might share them */
  @notree Sloc sloc;
  
  SyntaktikEntity[] children;
}
Routine {
  @notree
  Routine[] callers;
  @tree
  Routine[] dominators;
}

@tree
File {
  File[] children;
  /** several files could have the same name,
       but strings are implicitly @notree */
  string name;
  string content;
} 
\end{lstlisting}
Note: In case of the File example, there is no way to violate the tree property.
Note: It is legal for trees to form forests.


\subsubsection*{Constant Length Pointer}
The pointer is serialized using i64 instead of v64. Can be used on regular references and annotations. This restriction makes only sense if the generated supports lazy reading of partial storage pool and if the files that have to be dealt with would not fit into the main memory of the target machine. Using this restriction will most certainly increase the file size.

This restriction is serializable and thus, does not affect compatibility in any way.

Applies to fields.

Signature: constantLengthPointer()\footnote{The length of the name is intended.}

Defaults: none.

\begin{lstlisting}[label=constantLengthPointerExample,caption=Examples,language=skill]
/* stored points to information may exceed the available main memory, thus we have to access it directly from disk */
PointsToTargets {
  @constantLengthPointer
  Context context;
  @constantLengthPointer
  HeapObject object;
  @constantLengthPointer
  PointsToSet targets;
}
\end{lstlisting}

\subsection{Hints}
\label{hints}

Hints are annotations that start with a single \verb/!/ and are followed by a hint name. Hints are used to control the behavior of the generated language binding and do not have an impact on the semantics of the stored data. Therefore they will not be stored in the reflection pool.

\subsection*{Access}
Try to use a data structure that provides fast (random) access. E.g. an array list.

\subsection*{Modification}
Try to use a data structure that provides fast (random) modification. E.g. a linked list\footnote{Which has faster insert/delete operations than an array list.}.

\subsection*{Unique}
Serialization shall unify objects with exactly the same serialized form. In combination with the @unique restriction, there shall at most be an error reported on deserialization.

\subsection*{Distributed}
Use a static map instead of fields to represent fields of definitions in memory. This is usually an optimization if a definition has a lot of fields, but most use cases require only a small subset of them. Because hints do not modify the binary compatibility, some clients are likely to define the fields to be distributed or even lazy. Note that this will increase both the memory footprint and the access time for the given field and will only be a benefit for memory-cache locality reasons. The internal representation will change from \texttt{f.a}, i.e. a regular field, to \texttt{pool.a[f]}, i.e a map in the storage pool which holds the field data for each instance. Note that the presence of distributed, lazy or ignored fields will require objects to carry a pointer to their storage pool, which may eliminate the cache savings completely.

\subsection*{Lazy}
Deserialize the fields data only if it is actually used. Lazy implies distributed.

\subsection*{ReadOnly}
The generated code is unable to modify the respective field or instances of the respective type. This options is provided to provide a consistent API while preventing from logical errors, such as modifying data from a previous stage of computation.

\subsection*{Ignore}
The generated code is unable to access the respective field or any field of the type of the target declaration. This will lead to errors, if it is tried nonetheless. This option is provided to provide a consistent API for a combined file format, but restrict usage of certain fields, which should be transparent to the current stage of computation.
