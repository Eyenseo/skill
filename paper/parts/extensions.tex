\section{Restrictions}
Some invariants can be added to declarations and fields. These invariants can occur at the same place as comments, but can occur in any number. Invariants start with an \textsc{@} followed by a predicate. Each predicate has to supply a default argument \texttt{\%}, such that using only default arguments would not imply a restriction.
If multiple predicates are annotated, the conjunction of them forms the invariant.
The set of legal predicates is explained below.

If predicates, which are not directly applicable for compound types are used on compound types, they expand to the contents of the compound types, if applicable. Otherwise the usage of the predicate is illegal.

\todo{hier muss man zwischen serialisierbaren und nicht serialisierbaren restrictions unterscheiden; serialisierbar sind alle restrictions, die auch auswirkungen auf die potentiell gespeicherten daten haben, wie range und nonnull}

\subsection*{AsField}

maps:

In verbindung mit singletons kann man map-felder API-seitig zu feldern der interfaces machen!:)

Dadurch können sich einzelne tools felder ein und ausblenden, die dann zu maps serialisiert werden.

EP fordert, dass es einen Mechanismus gibt, der es einem erlaubt im nachhinein felder einzubauen;

Dieser Mechanismus erlaubt es einem zu jedem Zeitpunkt felder einzublenden; die gefahr ist hier, dass die Declarationen sehr unübersichtlich werden!

\subsection*{Range}
Range restrictions are used to restrict integers and floats.

Applies to fields: Integer, Float.

Signature: \verb/range(min, max)/: $\alpha \times \alpha → bool$

Defaults: obvious.

\begin{lstlisting}[label=rangeExample,caption=Examples,language=skill]
natural {
  @range(0,%)
  v64 data;
}
positive {
  @range(1,%)
  v64 data;
}
nonNegativeDouble {
  @range(0,%)
  f64 data;
}
\end{lstlisting}

\subsection*{NonNull}
Declares that an indexed field may not be null.

Applies to Field: Any indexed Type.

Signature: \verb/nonnull()/

Defaults: none.

\begin{lstlisting}[label=nonnullExample,caption=Examples,language=skill]
Node {
  @nonnull Node[] edges;
}
\end{lstlisting}


\subsection*{Unique}
Objects stored in a storage pool have to be distinct in their serialized form, i.e. for each pair of objects, there has to be at least one field, with a different value.

NOTE: This can cause difficulties in combination with sub-classing, because the uniqueness property must hold even on the part restricted to the topmost class declared to be unique.

Applies to Declarations of indexed types.

Signature: \verb/unique()/

Defaults: none.

\begin{lstlisting}[label=uniqueExample,caption=Examples,language=skill]
@unique Operator {
  string name;
}
@unique Term {
  Operator operator;
  Term[] arguments;
}
\end{lstlisting}


\subsection*{Singleton}
There is at most one instance of the declaration.

Applies to Declarations.

Signature: \verb/singleton()/

Defaults: none.

\begin{lstlisting}[label=singletonExample,caption=Examples,language=skill]
@singleton System { ... }
@singleton Data{
  /** Note: if data would not be a singleton itself, it is likely to violate the singleton property */
  System foo;
}
\end{lstlisting}


% \subsection*{Integer Renaming}
% In some languages it is possible to define subsets of integers by renameing the integer type. The type declaration must contain exactly one field of some integer type. The resulting type will be treated as integer type. Language support is encouraged to make use of language specific features such as typedefs. In Ada, this restriction should be processed together with the range restriction.


\subsection*{Ascription}
A language specific type can be ascribed to a field. The type has to be compatible to the fields actual type, because the ascription will not change the ABI in any way. The first argument is the language name. The second type is generator dependent, but should be related to types as they occur in local variable or field declaration in the respective language.

Although this kind of restriction puts a heavy burden on the language generator and decreases readability a lot, it can be used to increase the usability of the generated interface a lot, because language features such es enums in Java or unions and bitfields in C++ can be used.

Applies to fields.

Signature: \verb/as(language, type)/: $\texttt{string} \times \texttt{string} → \{\}$

Defaults: not allowed.

\begin{lstlisting}[label=ascriptionExample,caption=Examples,language=skill]
System {
  /**
  The language binding makes use of an enumeration, which is supplied with the generated code.
  
  The C++ interface will use the different type using C-Casts to convert between the two types (which is completely fine if the enum uses char as a base type).
  
  The Java interface will assume the stored integer to be the ordinal of the enum SystemState.
  */
  @as("C++", "ccast SystemState")
  @as("Java", "enum SystemState")
  i8 state
}
\end{lstlisting}



\subsection*{Tree}
The reference graph below created by objects of this type forms a tree. The type of the objects is irrelevant. Strings and fields with notree annotation, are not taken into account.

Applies to Declarations or Field.

Signature: \verb/tree()/

Defaults: none.


\subsubsection*{notree}
Applies to field.

Signature: \verb/notree()/

Defaults: none.

\begin{lstlisting}[label=treeExample,caption=Examples,language=skill]
Sloc{...}
@tree
SyntaktikEntity{
  /** not a tree, because several entities, might share them */
  @notree Sloc sloc;
  
  SyntaktikEntity[] children;
}
Routine {
  @notree
  Routine[] callers;
  @tree
  Routine[] dominators;
}

@tree
File {
  File[] children;
  /** several files could have the same name,
       but strings are implicitly @notree */
  string name;
  string content;
} 
\end{lstlisting}
Note: In case of the File example, there is no way to violate the tree property.
Note: It is legal for trees to form forests.


\section{Hints}
\label{hints}

Hints are annotations that start with a single \verb/!/ and are followed by a hint name.

\subsection*{Access}
Try to use a data structure that provides fast (random) access. E.g. an array list.

\subsection*{Modification}
Try to use a data structure that provides fast (random) modification. E.g. an linked list.

\subsection*{Unique}
Serialization shall unify objects with exactly the same serialized form. In combination with the @unique restriction, there shall at most be an error reported on deserialization.

\subsection*{Distributed}
Use a static map instead of fields to represent fields of definitions. This is usually an optimization if a definition has a lot of fields, but most use cases require only a small subset of them. Because hints do not modify the binary compatibility, some clients are likely to define the fields to be distributed or lazy.
\todo{f.a vs. a[f]}

\subsection*{Lazy}
Deserialize the fields data only if it is actually used. Lazy implies distributed.

\subsection*{Ignore}
The generated code is unable to access the respective field or any field of the type of the target declaration. This will lead to errors, if it is tried nonetheless. This option is provided to allow clients to reduce the memory footprint, if needed.
