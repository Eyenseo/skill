\section{Motivation}

Many industrial and scientific projects suffer from platform or language dependent representation of their core data structures. These problems often cause software engineers to stick with outdated tools or even programming languages, thus causing a lot of frustration. This does not only increase the burden of hiring new project members, but can ultimately cause a project to die unnecessarily.

The approach presented in this paper provides means of platform and language independent specification of serializable data structures and therefore a safe way to let old tools of a tool suite talk to the knew ones, without even the need of recompiling the old ones.

In order to achieve this goal, we introduce two new concepts:

The first one is an easy to use specification language for data structures providing simple data types like integers and strings, abstract data types like sets and maps, type safe pointers, extension points and single inheritance.

The second one is a formalized mapping of specified types to a bitwise representation of stored objects. The mapping is very compact and therefore scalable, easy to understand and therefore easy to bind to a new language. It does encode the type system and can therefore provide a maximum of upward and downward compatibility, while maintaining type safety at the same time. It allows for a maximum of safety when it comes to manipulating data that unknown to the generated interface, while maintaining high decoding and encoding speeds\footnote{The serialization and deserialization operations are linear in the size of the input/output file.}.

In contrast to other serialization formats such as XML, the serializable data can not be viewed or modified with a text editor. This however does not mean, that it is not human readable, because one can provide a human usable editor to edit arbitrary skill files.

A further improvement over XML is, that the reflective usage of stored data is expected to be quite rare, because the binding generator is able to generate an interface that ensures type safety of modifications and provides a nice integration into the target language.

The expected file sizes range from 1 MiB to 2 GiB, while having virtually no relevant numerical limits in the file size\footnote{There are practical limits, such as Java having array lengths limited to ~$2^{31}$ or current file systems having a maximum file size limit that is roughly equivalent to the size of a file completely occupied by objects with a single field of a single byte. There will also be problems with raw I/O-Performance for very large files and an implementation of a binding generator, which can handle files not storable in the main memory is a tricky thing to do.}. Please note, that the skill file format is a lot more compact then equivalent XML files would be.
It is expected, that files contain objects of hundreds of types with thousands of instances each. If a type in such a file would contain in average three pointers, the file size would still be around a mega byte, which is due to the explicit design goal of having a very small footprint. This will also lead to high load and store performance, because the raw disk speed will usually be the limiting factor.


\subsection{Scientific Contributions}

This section is a very concise representation of contributions, that in part have already been mentioned above and in parts, will be mentioned much later.

The suggested serialization format and serialization language offer all of the following features at the same time:
\begin{itemize}
 \item a small footprint and therefore high decoding speeds
 \item a fully reflective type encoding
 \item type safe storage of pointers both to known and unknown types\footnote{I.e. regular references and annotations.}
 \item the specification of a file format is modular\footnote{I.e. it can be distributed over many files.} and easy to use
 \item no tool using a common intermediate representation has to know the complete specification. It is even possible to strip away or add individual fields of commonly used types.
 \item the coding is platform and language independent
 \item the coding offers a maximum of downward \textbf{and} upward compatibility
 \item a programmer is communicating through a generated interface, which allows programmers knowing nothing about skill to interact with it, ensures type safety easily and allows programmers to write tools in the language they know the best\footnote{This is a problem especially in the scientific community, where many researchers work on similar problems but on completely different tools.}
 \item stored data, that is never needed by a tool, will never be touched
\end{itemize}

Any of the arguments above have already been made in various contexts \todo{cite, cite, cite; llvm tutorial ``llvm and perl'', platform independent javabytecode, IDL, ada serialization, custom binary formats}, but there is no solution bringing all these demands together into a single product that does the job automatically.


\subsection{Related Work}

There are many approaches similar to ours, but most of them have a different focus. This section shall provide a concise list of related approaches. For potential users of skill, this might also present alternatives superior for individual use cases.

\subsection*{XML}

XML is a file format and might in fact be used as a backend. If a human readable storage on disk is not required, a binary encoding can be used to improve load/store performance significantly.

In contrast to our approach, XML requires the serialized data to form a tree. In theory, this is not a real problem, because there is at least one canonical transformation, which turns a graph into a tree (by adding a node and some attributes). On the other hand, such a transformation will in most cases take away the readability of the serialized data, which makes XML pointless.

\subsubsection*{XML Schema definitions}

The description language itself is more or less equivalent to most schema definition languages such as XML Schema \todo{cite w3c}. The downside is that schema definitions have to operate on XML and can not directly be used with a binary format. There is also
no way to generate code for some client languages, including Ada, from a schema definition.

\subsubsection*{JAXP and xmlbeansxx}

For Java and C++, there are code generators, which can turn a XML schema file into code, which is able to deal with an XML in a similar way, as it is proposed by this work. In case of Java this is even in the standard library. The downside is, that, to our knowledge, this is only possible for Java and C++, thus it leaves us with portability issues. A minor problem of this approach is the lack of support for comment generation and the inefficient storage of serialized data.
An interesting observation is, that this approach deprives XML of its flexibility advantage over our solution. \todo{brr}


\subsection*{ASN.1}

Is not powerful enough to fit our purpose.

\subsection*{IDL}

A concise description of IDL can be fonud in \todo{ref David Lamb}. It seems not to be powerful enough and is certainly outdated. It is so old, that there are no bindings for any modern language. There is also not much documentation on further research on that area, thus creating a new approach with similar goals but modern techniques is in fact an option.


\subsection*{Apatche Thrift \& Protobuf}

Lacks subtypeing. Protobuf has a overly complex notation language. Both seem to be optimized for network protocols, thus they do not have storage pools, which are the foundation of our serialization approach and an absolute requirement for some of our features, such as hints (see section \ref{hints}).


\subsection*{Java Bytecode, LLVM/IR and others}

Although Java Bytecode and the LLVM intermediate representation are hand crafted formats, they served as a guiding example in many ways.


\subsection*{Language Specific}

Language specific is language specific and can therefore not be used to interface between subsystems written different programming languages such as Ada, Java, C or Haskell. Plus not every language offers such a mechanism. E.g. C.


\subsection*{Language Interfaces}
Language Interfaces do not permit serialization capabilities. Most language only provide interfaces for C, with varying quality and varying degree of automation. A significant problem are interfaces between languages with different memory models.
Interfaces between languages with different type systems are simply unproductive:D
