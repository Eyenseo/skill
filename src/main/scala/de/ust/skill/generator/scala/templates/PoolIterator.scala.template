/**
 * Implements iteration over members of a storage pool.
 *
 * @param T is the API type of the objects stored in the static type storage pool
 * @author Timm Felden
 */
class PoolIterator[T <: KnownType] private[internal] (val staticType: KnownPool[T, _]) extends Iterator[T] {

  // pools are usually separated into several blocks and new instances; block -2 means the iterator is invalid
  private var currentBlock = -2
  private val blocks = staticType.userType.blockInfos
  // the index in the dynamic type pool
  private var index = 0L
  // move to the first valid position
  reset

  // the current type we are looking into
  private var dynamicType: KnownPool[_ <: T, _] = staticType

  /**
   * note that this iterator is based on the current index, therefore it might behave in an unexpected way in case of
   *  parallel modification.
   *
   * @pre valid
   * @return the current element
   */
  private def get(): T = {
    require(hasNext)
    if (-1 == currentBlock)
      dynamicType.newObjects(index.toInt)
    else
      staticType.getByID(index)
  }

  /**
   * move to the next valid element, if any exists; invalidate the iterator otherwise
   */
  override def next(): T = {
    val result = get

    // are we still in the block part?
    if (-1 != currentBlock && blocks.contains(currentBlock)) {
      // assume the next position is the next index
      index += 1

      // check if there is another instance in the current block
      if (blocks(currentBlock).bpsi + blocks(currentBlock).count > index)
        return result
      else {
        // check if there is another instane in a block
        for (i ← currentBlock + 1 until staticType.blockCount) {
          if (blocks.contains(i) && blocks(i).count > 0) {
            index = blocks(i).bpsi
            currentBlock = i
            return result
          }
        }
      }
      // we iterated over all instances from the deserialized file; invalidate the currentBlock
      currentBlock = -1
      index = -1
    }

    // we are in the newObjects part; reset index and abuse it to move through the dynamic type stack
    if (-1 == currentBlock) {
      index += 1
      if (index < dynamicType.newObjects.length) {
        return result
      }

      // TODO check if next points to a type above staticType

      //advance to next pool
      var next = dynamicType.next
      index = 0
      while (null != next && 0 == index) {

        if (next.isInstanceOf[KnownPool[_ <: T, _]]) {
          dynamicType = next.asInstanceOf[KnownPool[_ <: T, _]]
          if (0 != dynamicType.newObjects.length) {
            index = 0
            return result
          }
        }

        next = next.next
      }
    }

    // invalidate the iterator, because there are no more instances
    currentBlock = -2
    return result
  }

  /**
   * check if the iterator is still valid; the obvious way of invalidating an iterator is to walk over all iterable
   *  elemnts.
   */
  def hasNext = -2 != currentBlock

  /**
   * resets the cursor to the first valid position, if any
   *
   * TODO move through newObjects as well; this is required if the loaded file did not contain any instances of
   *  static type
   */
  def reset() {
    currentBlock = 0
    val max = staticType.blockCount
    for (i ← 0 until max) {
      if (blocks.contains(i) && blocks(i).count > 0) {
        index = blocks(i).bpsi
        currentBlock = i
        return
      }
    }
  }
}