
case class ByteOffsetPosition(offset: Int) extends Position {
  final val line = 1
  def column = offset + 1
  def lineContents: String = ""
}

/**
 * @note the push/pop capabilities must be treated with care
 * @note the underlying implementation will very likely break backtracking capabilities of a combined parser
 *
 * @author Timm Felden
 */
final class ByteReader(val stream: FileChannel) extends Reader[Byte] {
  def this(path: Path) = this(Files.newByteChannel(path, StandardOpenOption.READ).asInstanceOf[FileChannel])
  // this buffer is reused for any allocation below 64bytes
  private val smallBuf = ByteBuffer.allocate(64)

  private var positions = new Stack[Long]
  /**
   * saves the current position onto a stack and jumps to the argument position
   */
  def push(next: Long) { positions.push(stream.position); stream.position(next) }
  /**
   * returns to the last position saved
   */
  def pop: Unit = stream.position(positions.pop)

  override def offset = stream.position().toInt
  def position = stream.position()

  override def first: Byte = throw new NoSuchMethodError("unsupported operation")
  override def rest: ByteReader = throw new NoSuchMethodError("unsupported operation")
  def pos: Position = ByteOffsetPosition(offset)
  def atEnd = stream.size() == stream.position()
  def minimumBytesToGo = stream.size() - stream.position()

  override def drop(n: Int): ByteReader = {
    if (has(n))
      stream.position(stream.position + n);
    else
      UnexpectedEOF(s"while dropping $n bytes")
    this
  }
  /**
   * takes n bytes from the stream; the buffer may be invalid after the next call of this function
   */
  private[parsers] def take(n: Int): ByteBuffer = {
    if (n < 64) {
      smallBuf.clear(); smallBuf.limit(n)
      stream.read(smallBuf); smallBuf.position(0)
      smallBuf
    } else {
      val r = ByteBuffer.allocate(n);
      stream.read(r); r.rewind();
      r
    }
  }
  /**
   * like take, but creates a copy of the taken bytes to ensure correct usage
   */
  private[internal] def bytes(n: Int): Array[Byte] = {
    if (n < 64)
      Arrays.copyOf(take(n).array, n)
    else
      take(n).array
  }

  def has(n: Int): Boolean = stream.size() >= (n + stream.position())
  def next: Byte = try {
    take(1).get
  } catch { case e: Exception â‡’ UnexpectedEOF("there's no next byte", e) }
}