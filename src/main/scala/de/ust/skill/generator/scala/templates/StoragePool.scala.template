
/**
 * Marker to indicate that a pool has a type known at generation time.
 *
 * @author Timm Felden
 */
trait KnownPool {
  /**
   * Can be used on known pools to construct instances of the pool, AFTER the sub pool relation has been constructed.
   */
  private[internal] def constructPool(): Unit

  /**
   * Reads all fields required by the generation time specification.
   */
  private[internal] def readFields(): Unit
}

/**
 * General purpose storage pool, which is used if for unknown types. Other storage pool inherit from this class.
 *
 * @param userType the type of the objects stored in this pool
 * @param superPool Some(super) if super is the pool containing the super type instances;
 * @param blockCount the number of blocks the pool had in the file creating the pool; will be 0 if the pool has not been
 *                    created by a file
 *
 * @author Timm Felden
 */
class StoragePool(
    val userType: UserType,
    val superPool: Option[StoragePool],
    val blockCount: Int) {
  val name = userType.name
  val basePool: StoragePool = superPool match {
    case Some(base) ⇒ base.basePool
    case None       ⇒ this
  };

  /**
   * true iff the pool has a shallow modification, i.e. an index may have changed
   */
  protected[this] var dirty = false;

  /**
   * T is the type of elements stored in this pool. This feature will be used to create sub pools for known types.
   */
  protected type T <: AnyRef

  /**
   * the sub pools are constructed during construction of all storage pools of a state
   */
  protected var subPools = new ArrayBuffer[StoragePool]

  var f: Array[Void] = null

  /**
   * Maps names to indices in the actual object, i.e. the first valid index in a storage pool can start at an arbitrary
   *  positive number, but indices of base pools will start at 0.
   */
  var fieldNames = new HashMap[String, Int]
  /**
   * Maps field indices to types. Contains types of super types as well.
   */
  var fieldTypes = new HashMap[Int, TypeInfo]

  // initialize field names types
  {
    if (superPool.isDefined) {
      fieldNames ++= superPool.get.fieldNames
      fieldTypes ++= superPool.get.fieldTypes
      superPool.get.subPools += this
    }
    userType.fields.foreach({ f ⇒
      fieldTypes.put(fieldNames.size, f.t)
      fieldNames.put(f.name, fieldNames.size)
    })
  }

  /**
   * All stored objects, which have exactly the type T. Objects are stored as arrays of field entries. The types of the
   *  respective fields can be retrieved using the fieldTypes map.
   */
  // BASETYPE private[internal] var data: Array[T] = new Array[T](storedSize.toInt)
  private[internal] var newObjects = ArrayBuffer[T]()

  /**
   * size is an O(t) opertion, because all subtypes have to be querried
   */
  def sizeCount: Long = {
    // TODO horribly incorrect
    userType.instanceCount
  }

  def getIterator(): Iterator[T] = new Iterator[T](this)

  /**
   * Retrieves an element based on its current index.
   *
   * TODO horribly incorrect; does not allow for new instances!!!
   */
  def getByCurrentIndex(index: Long): T = getByID(index)

  /**
   * Retrieves an element based on its ID, i.e. its original index in the deserialized file.
   *
   * @note will only work if the state has been read from a file or been written to a file
   */
  def getByID(index: Long): T = {
    if (basePool.isInstanceOf[KnownPool])
      return basePool.getByID(index).asInstanceOf[T];
    else
      throw new NoSuchMethodError(s"Can not be called on a fully generic storage pool: $name");
  }

  /**
   * prepares serialization, i.e. ensures that all objects get IDs, which can be used as logic pointers,
   * and can be written to disk
   */
  private[internal] def prepareSerialization(σ: SerializableState) {

  }

  private[internal] def writeFieldData(out: ByteArrayOutputStream, σ: SerializableState) {}

  protected var endOffsets = new HashMap[FieldDeclaration, Long]()
}

object StoragePool {
  val NONE: Iterable[StoragePool] = List[StoragePool]()
}