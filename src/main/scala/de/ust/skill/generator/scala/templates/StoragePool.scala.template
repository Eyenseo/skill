
/**
 * General purpose storage pool, which is used if for unknown types. Other storage pool inherit from this class.
 *
 * @author Timm Felden
 */
class StoragePool(
    val name: String, val userType: UserType, val superPool: Option[StoragePool],
    var storedSize: Long, var basePoolStartIndex: Long) {

  /**
   * true iff the pool has a shallow modification, i.e. an index may have changed
   */
  protected[this] var dirty = false;

  /**
   * T is the type of elements stored in this pool. This feature will be used to create sub pools for known types.
   */
  protected type T <: AnyRef

  var subPools = new ArrayBuffer[StoragePool]

  var f: Array[Void] = null

  /**
   * Maps names to indices in the actual object, i.e. the first valid index in a storage pool can start at an arbitrary
   *  positive number, but indices of base pools will start at 0.
   */
  var fieldNames = new HashMap[String, Int]
  /**
   * Maps field indices to types. Contains types of super types as well.
   */
  var fieldTypes = new HashMap[Int, TypeInfo]

  // initialize field names types
  {
    if (superPool.isDefined) {
      fieldNames ++= superPool.get.fieldNames
      fieldTypes ++= superPool.get.fieldTypes
    }
    userType.fields.foreach({ f ⇒
      fieldTypes.put(fieldNames.size, f.t)
      fieldNames.put(f.name, fieldNames.size)
    })
  }

  /**
   * All stored objects, which have exactly the type T. Objects are stored as arrays of field entries. The types of the
   *  respective fields can be retrieved using the fieldTypes map.
   */
  private[internal] var data: ArrayBuffer[T] = new ArrayBuffer[T](storedSize.toInt)

  def sizeCount: Long = {
    if (null == data)
      storedSize;
    else
      data size;
  }

  /**
   * Retrieves an element based on its current index.
   */
  def getByCurrentIndex(index: Long): T = {
    return data(index.toInt - 1)
  }

  /**
   * Retrieves an element based on its ID, i.e. its original index in the deserialized file.
   *
   * @note will only work if the state has been read from a file or been written to a file
   */
  def getByID(index: Long): T = {
    return data(index.toInt - 1)
  }

  /**
   * prepares serialization, i.e. ensures that all objects get IDs, which can be used as logic pointers,
   * and can be written to disk
   */
  private[internal] def prepareSerialization(σ: SerializableState) {

  }

  protected var endOffsets = new HashMap[FieldDeclaration, Long]()
  /**
   * writes fields from memory into their serialized form.
   * saves end-offsets for writing the header
   */
  private[internal] def writeFieldData(out: ByteArrayOutputStream, σ: SerializableState) {
    userType.fields.foreach(writeFieldData(out, σ, _))
  }

  protected[this] def writeFieldData(out: ByteArrayOutputStream, σ: SerializableState, f: FieldDeclaration) {
    // TODO write generic field data

    // note this is only correct if data is written; for now this will cause errors, but the bug is the TODO above
    endOffsets.put(f, out.size)
  }

  import SerializableState.v64

  /**
   * writes the pool into a file, after all pools of a state have been prepared
   *
   * the resulting layout is described in SKilL §6.2
   */
  final private[internal] def write(out: FileChannel, σ: SerializableState) {
    // little helpers
    def writeV64(i: Long) = out.write(ByteBuffer.wrap(v64(i)))
    def putName(s: String) = writeV64(σ.strings.serializationIDs(s))

    //string typeName
    putName(name)

    //string superTypeName &&
    //option(v64 basePoolStartIndex; iff has superType)
    superPool match {
      case None ⇒ writeV64(0)
      case Some(s) ⇒ {
        putName(s.name)
        writeV64(basePoolStartIndex)
      }
    }

    //v64 elementCount
    writeV64(sizeCount)

    //restriction[] REST
    // TODO write restrictions
    writeV64(0)

    //v64 fieldCount
    writeV64(userType.fields.length)

    //foreach f in fields
    userType.fields.foreach({ f ⇒
      // restriction[] f.REST
      // TODO write restrictions
      writeV64(0)

      //[[f.type]]
      writeV64(f.t.typeId)

      //string f.name
      putName(f.name)
      writeV64(endOffsets(f))
    })

  }
}

object StoragePool {
  val NONE: Iterable[StoragePool] = List[StoragePool]()
}