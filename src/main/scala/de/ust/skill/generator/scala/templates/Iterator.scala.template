/**
 * Implements iteration over members of a storage pool.
 *
 * @param T is in fact the API type of the objects stored in the static type storage pool
 * @author Timm Felden
 */
class Iterator[T <: AnyRef] private[internal] (val staticType: StoragePool) extends Traversable[T] {

  // the index in the dynamic type pool; if we iterated over all pools, the index will be set to 0
  private var index = 1L

  // the current type we are looking into
  private var dynamicType = staticType

  /**
   * note that this iterator is based on the current index, therefore it might behave in an unexpected way in case of
   *  parallel modification.
   *
   * @pre valid
   * @return the current element
   */
  implicit def get(): T = {
    require(valid)
    return staticType.getByCurrentIndex(index).asInstanceOf[T]
  }

  /**
   * move to the next element
   */
  def next() = {
    // TODO not correct!!! (need to consider sub types, blocks and new instances)
    if (index >= dynamicType.sizeCount)
      index = 0
    else
      index += 1
  }

  /**
   * check if the iterator is still valid; the obvious way of invalidating an iterator is to walk over all iterable
   *  elemnts.
   */
  def valid = 0 != index

  def foreach[U](f: T ⇒ U) = while (valid) { f(get); next }

  /**
   * like foreach, but provides an index as well
   * @note index starts from 1
   * @note invalidates the iterator
   */
  def indexedForeach(f: (T, Long) ⇒ Unit) = while (valid) { f(get, index); next }
}