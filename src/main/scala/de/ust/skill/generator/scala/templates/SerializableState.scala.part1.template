
/**
 * This class is used to handle objects in a serializable state.
 *
 * @author Timm Felden
 */
final class SerializableState extends SkillState {
  import SerializableState._

  /**
   * path of the file, the serializable state has been created from; this is required for lazy evaluation and appending
   *
   * null iff the state has not been created from a file
   */
  private[internal] var fromReader: ByteReader = null

  private[internal] lazy val serializationFunction = new SerializationFunctions(this)

  private[internal] var pools = new HashMap[String, AbstractPool]
  @inline def knownPools = pools.values.collect({ case p: KnownPool[_, _] ⇒ p });

  private[internal] val strings = new StringPool

  /**
   * Creates a new SKilL file at target.
   */
  def write(target: Path) {
    import serializationFunction._
    val file = Files.newByteChannel(target,
      StandardOpenOption.CREATE,
      StandardOpenOption.WRITE,
      StandardOpenOption.TRUNCATE_EXISTING).asInstanceOf[FileChannel]

    // collect all known objects
    // TODO implementation
    strings.prepareSerialization(this)

    // prepare pools, i.e. ensure that all objects get IDs which can be turned into logic pointers
    knownPools.foreach(_.prepareSerialization(this))

    // write string pool
    strings.write(file, this)

    // write count of the type block
    file.write(ByteBuffer.wrap(v64(pools.size)))

    // write fields back to their buffers
    val out = new ByteArrayOutputStream

    // write header
    knownPools.foreach(_.write(file, out, this))

    // write data
    file.write(ByteBuffer.wrap(out.toByteArray()))

    // done:)
    file.close()
  }

  /**
   * retrieves a string from the known strings; this can cause disk access, due to the lazy nature of the implementation
   *
   * @throws ArrayOutOfBoundsException if index is not valid
   */
  def getString(index: Long): String = {
    if (0 == index)
      return null

    strings.idMap.get(index) match {
      case Some(s) ⇒ s
      case None ⇒ {
        if (index > strings.stringPositions.size)
          InvalidPoolIndex(index, strings.stringPositions.size, "string")

        val off = strings.stringPositions(index)
        fromReader.push(off._1)
        var chars = fromReader.bytes(off._2)
        fromReader.pop

        val result = new String(chars, "UTF-8")
        strings.idMap.put(index, result)
        result
      }
    }
  }

  /**
   * adds a string to the state
   */
  def addString(string: String) {
    strings.newStrings += string
  }