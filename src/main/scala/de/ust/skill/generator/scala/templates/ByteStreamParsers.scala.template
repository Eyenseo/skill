
/**
 * @note This parser does not support backtracking. If one would be interest in backtracking the atomic parsers should
 *  use the in.mark and in.reset methods if they fail.
 *
 * @author Timm Felden
 */
class ByteStreamParsers extends Parsers {
  type Elem = Byte
  protected implicit def readerToByteReader(x: Input): ByteReader = x.asInstanceOf[ByteReader]

  def hasMore(): Parser[Unit] = new Parser[Unit] {
    def apply(in: Input) = {
      if (in.atEnd)
        Failure("EOF", in)
      else
        Success((), in)
    }
  }

  def bytes(n: Int): Parser[Array[Byte]] = new Parser[Array[Byte]] {
    def apply(in: Input) = {
      if (in has n)
        Success(Arrays.copyOf((in take n).array, n), in)
      else
        UnexpectedEOF(s"while taking $n bytes")
    }
  }
  def bytes(n: Long): Parser[Array[Byte]] = bytes(n.asInstanceOf[Int])

  def i8 = new Parser[Byte] {
    def apply(in: Input) = {
      if (in has 1)
        Success(in.next, in)
      else UnexpectedEOF("while reading i8")
    }
  }
  def i16 = new Parser[Short] {
    def apply(in: Input) = {
      if (in has 2)
        Success((in take 2).getShort, in)
      else
        UnexpectedEOF("while reading i16")
    }
  }
  def i32 = new Parser[Int] {
    def apply(in: Input) = {
      if (in has 4)
        Success((in take 4).getInt, in)
      else
        UnexpectedEOF("while reading i32")
    }
  }
  def i64 = new Parser[Long] {
    def apply(in: Input) = {
      if (in has 8)
        Success((in take 8).getLong, in)
      else
        UnexpectedEOF("while reading i64")
    }
  }

  def v64 = new Parser[Long] {
    def apply(in: Input) = {
      try {
        var count: Long = 0
        var rval: Long = 0
        var r: Long = in.next
        while (count < 8 && 0 != (r & 0x80)) {
          rval |= (r & 0x7f) << (7 * count);

          count += 1;
          r = in.next
        }
        rval = (rval | (count match {
          case 8 ⇒ r
          case _ ⇒ (r & 0x7f)
        }) << (7 * count));
        Success(rval, in)
      } catch {
        case e: Exception ⇒ UnexpectedEOF("while reading v64", e)
      }
    }
  }

  def f32 = new Parser[Float] {
    def apply(in: Input) = {
      if (in has 4)
        Success((in take 4).getFloat, in)
      else
        UnexpectedEOF("while reading f32")
    }
  }
  def f64 = new Parser[Double] {
    def apply(in: Input) = {
      if (in has 8)
        Success((in take 8).getDouble, in)
      else
        UnexpectedEOF("while reading f64")
    }
  }

  def string(σ: SerializableState) = v64 ^^ {
    _ match {
      case 0 ⇒ null
      case i ⇒ σ.getString(i)
    }
  }

  /**
   * Inserts a try/catch block emitting a useful message into the parser.
   */
  def tryCatch[U](p: Parser[U])(msg: String) = new Parser[U] {
    def apply(in: Input) = try { p.apply(in) } catch { case e: SkillException ⇒ SkillException(msg, e) }
  }
}